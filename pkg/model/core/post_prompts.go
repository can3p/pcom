// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package core

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// PostPrompt is an object representing the database table.
type PostPrompt struct {
	ID          string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	AskerID     string      `boil:"asker_id" json:"asker_id" toml:"asker_id" yaml:"asker_id"`
	RecipientID string      `boil:"recipient_id" json:"recipient_id" toml:"recipient_id" yaml:"recipient_id"`
	Message     string      `boil:"message" json:"message" toml:"message" yaml:"message"`
	DismissedAt null.Time   `boil:"dismissed_at" json:"dismissed_at,omitempty" toml:"dismissed_at" yaml:"dismissed_at,omitempty"`
	PostID      null.String `boil:"post_id" json:"post_id,omitempty" toml:"post_id" yaml:"post_id,omitempty"`
	CreatedAt   time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt   time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *postPromptR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L postPromptL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PostPromptColumns = struct {
	ID          string
	AskerID     string
	RecipientID string
	Message     string
	DismissedAt string
	PostID      string
	CreatedAt   string
	UpdatedAt   string
}{
	ID:          "id",
	AskerID:     "asker_id",
	RecipientID: "recipient_id",
	Message:     "message",
	DismissedAt: "dismissed_at",
	PostID:      "post_id",
	CreatedAt:   "created_at",
	UpdatedAt:   "updated_at",
}

var PostPromptTableColumns = struct {
	ID          string
	AskerID     string
	RecipientID string
	Message     string
	DismissedAt string
	PostID      string
	CreatedAt   string
	UpdatedAt   string
}{
	ID:          "post_prompts.id",
	AskerID:     "post_prompts.asker_id",
	RecipientID: "post_prompts.recipient_id",
	Message:     "post_prompts.message",
	DismissedAt: "post_prompts.dismissed_at",
	PostID:      "post_prompts.post_id",
	CreatedAt:   "post_prompts.created_at",
	UpdatedAt:   "post_prompts.updated_at",
}

// Generated where

var PostPromptWhere = struct {
	ID          whereHelperstring
	AskerID     whereHelperstring
	RecipientID whereHelperstring
	Message     whereHelperstring
	DismissedAt whereHelpernull_Time
	PostID      whereHelpernull_String
	CreatedAt   whereHelpertime_Time
	UpdatedAt   whereHelpertime_Time
}{
	ID:          whereHelperstring{field: "\"post_prompts\".\"id\""},
	AskerID:     whereHelperstring{field: "\"post_prompts\".\"asker_id\""},
	RecipientID: whereHelperstring{field: "\"post_prompts\".\"recipient_id\""},
	Message:     whereHelperstring{field: "\"post_prompts\".\"message\""},
	DismissedAt: whereHelpernull_Time{field: "\"post_prompts\".\"dismissed_at\""},
	PostID:      whereHelpernull_String{field: "\"post_prompts\".\"post_id\""},
	CreatedAt:   whereHelpertime_Time{field: "\"post_prompts\".\"created_at\""},
	UpdatedAt:   whereHelpertime_Time{field: "\"post_prompts\".\"updated_at\""},
}

// PostPromptRels is where relationship names are stored.
var PostPromptRels = struct {
	Asker     string
	Post      string
	Recipient string
}{
	Asker:     "Asker",
	Post:      "Post",
	Recipient: "Recipient",
}

// postPromptR is where relationships are stored.
type postPromptR struct {
	Asker     *User `boil:"Asker" json:"Asker" toml:"Asker" yaml:"Asker"`
	Post      *Post `boil:"Post" json:"Post" toml:"Post" yaml:"Post"`
	Recipient *User `boil:"Recipient" json:"Recipient" toml:"Recipient" yaml:"Recipient"`
}

// NewStruct creates a new relationship struct
func (*postPromptR) NewStruct() *postPromptR {
	return &postPromptR{}
}

func (r *postPromptR) GetAsker() *User {
	if r == nil {
		return nil
	}
	return r.Asker
}

func (r *postPromptR) GetPost() *Post {
	if r == nil {
		return nil
	}
	return r.Post
}

func (r *postPromptR) GetRecipient() *User {
	if r == nil {
		return nil
	}
	return r.Recipient
}

// postPromptL is where Load methods for each relationship are stored.
type postPromptL struct{}

var (
	postPromptAllColumns            = []string{"id", "asker_id", "recipient_id", "message", "dismissed_at", "post_id", "created_at", "updated_at"}
	postPromptColumnsWithoutDefault = []string{"id", "asker_id", "recipient_id", "message", "created_at", "updated_at"}
	postPromptColumnsWithDefault    = []string{"dismissed_at", "post_id"}
	postPromptPrimaryKeyColumns     = []string{"id"}
	postPromptGeneratedColumns      = []string{}
)

type (
	// PostPromptSlice is an alias for a slice of pointers to PostPrompt.
	// This should almost always be used instead of []PostPrompt.
	PostPromptSlice []*PostPrompt

	postPromptQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	postPromptType                 = reflect.TypeOf(&PostPrompt{})
	postPromptMapping              = queries.MakeStructMapping(postPromptType)
	postPromptPrimaryKeyMapping, _ = queries.BindMapping(postPromptType, postPromptMapping, postPromptPrimaryKeyColumns)
	postPromptInsertCacheMut       sync.RWMutex
	postPromptInsertCache          = make(map[string]insertCache)
	postPromptUpdateCacheMut       sync.RWMutex
	postPromptUpdateCache          = make(map[string]updateCache)
	postPromptUpsertCacheMut       sync.RWMutex
	postPromptUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// OneP returns a single postPrompt record from the query, and panics on error.
func (q postPromptQuery) OneP(ctx context.Context, exec boil.ContextExecutor) *PostPrompt {
	o, err := q.One(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single postPrompt record from the query.
func (q postPromptQuery) One(ctx context.Context, exec boil.ContextExecutor) (*PostPrompt, error) {
	o := &PostPrompt{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "core: failed to execute a one query for post_prompts")
	}

	return o, nil
}

// AllP returns all PostPrompt records from the query, and panics on error.
func (q postPromptQuery) AllP(ctx context.Context, exec boil.ContextExecutor) PostPromptSlice {
	o, err := q.All(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all PostPrompt records from the query.
func (q postPromptQuery) All(ctx context.Context, exec boil.ContextExecutor) (PostPromptSlice, error) {
	var o []*PostPrompt

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "core: failed to assign all query results to PostPrompt slice")
	}

	return o, nil
}

// CountP returns the count of all PostPrompt records in the query, and panics on error.
func (q postPromptQuery) CountP(ctx context.Context, exec boil.ContextExecutor) int64 {
	c, err := q.Count(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all PostPrompt records in the query.
func (q postPromptQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "core: failed to count post_prompts rows")
	}

	return count, nil
}

// ExistsP checks if the row exists in the table, and panics on error.
func (q postPromptQuery) ExistsP(ctx context.Context, exec boil.ContextExecutor) bool {
	e, err := q.Exists(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q postPromptQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "core: failed to check if post_prompts exists")
	}

	return count > 0, nil
}

// Asker pointed to by the foreign key.
func (o *PostPrompt) Asker(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AskerID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// Post pointed to by the foreign key.
func (o *PostPrompt) Post(mods ...qm.QueryMod) postQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PostID),
	}

	queryMods = append(queryMods, mods...)

	return Posts(queryMods...)
}

// Recipient pointed to by the foreign key.
func (o *PostPrompt) Recipient(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.RecipientID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// LoadAsker allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (postPromptL) LoadAsker(ctx context.Context, e boil.ContextExecutor, singular bool, maybePostPrompt interface{}, mods queries.Applicator) error {
	var slice []*PostPrompt
	var object *PostPrompt

	if singular {
		var ok bool
		object, ok = maybePostPrompt.(*PostPrompt)
		if !ok {
			object = new(PostPrompt)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePostPrompt)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePostPrompt))
			}
		}
	} else {
		s, ok := maybePostPrompt.(*[]*PostPrompt)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePostPrompt)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePostPrompt))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &postPromptR{}
		}
		args[object.AskerID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postPromptR{}
			}

			args[obj.AskerID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Asker = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.AskerPostPrompts = append(foreign.R.AskerPostPrompts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AskerID == foreign.ID {
				local.R.Asker = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.AskerPostPrompts = append(foreign.R.AskerPostPrompts, local)
				break
			}
		}
	}

	return nil
}

// LoadPost allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (postPromptL) LoadPost(ctx context.Context, e boil.ContextExecutor, singular bool, maybePostPrompt interface{}, mods queries.Applicator) error {
	var slice []*PostPrompt
	var object *PostPrompt

	if singular {
		var ok bool
		object, ok = maybePostPrompt.(*PostPrompt)
		if !ok {
			object = new(PostPrompt)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePostPrompt)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePostPrompt))
			}
		}
	} else {
		s, ok := maybePostPrompt.(*[]*PostPrompt)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePostPrompt)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePostPrompt))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &postPromptR{}
		}
		if !queries.IsNil(object.PostID) {
			args[object.PostID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postPromptR{}
			}

			if !queries.IsNil(obj.PostID) {
				args[obj.PostID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`posts`),
		qm.WhereIn(`posts.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Post")
	}

	var resultSlice []*Post
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Post")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for posts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for posts")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Post = foreign
		if foreign.R == nil {
			foreign.R = &postR{}
		}
		foreign.R.PostPrompts = append(foreign.R.PostPrompts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PostID, foreign.ID) {
				local.R.Post = foreign
				if foreign.R == nil {
					foreign.R = &postR{}
				}
				foreign.R.PostPrompts = append(foreign.R.PostPrompts, local)
				break
			}
		}
	}

	return nil
}

// LoadRecipient allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (postPromptL) LoadRecipient(ctx context.Context, e boil.ContextExecutor, singular bool, maybePostPrompt interface{}, mods queries.Applicator) error {
	var slice []*PostPrompt
	var object *PostPrompt

	if singular {
		var ok bool
		object, ok = maybePostPrompt.(*PostPrompt)
		if !ok {
			object = new(PostPrompt)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePostPrompt)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePostPrompt))
			}
		}
	} else {
		s, ok := maybePostPrompt.(*[]*PostPrompt)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePostPrompt)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePostPrompt))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &postPromptR{}
		}
		args[object.RecipientID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postPromptR{}
			}

			args[obj.RecipientID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Recipient = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.RecipientPostPrompts = append(foreign.R.RecipientPostPrompts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.RecipientID == foreign.ID {
				local.R.Recipient = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.RecipientPostPrompts = append(foreign.R.RecipientPostPrompts, local)
				break
			}
		}
	}

	return nil
}

// SetAskerP of the postPrompt to the related item.
// Sets o.R.Asker to related.
// Adds o to related.R.AskerPostPrompts.
// Panics on error.
func (o *PostPrompt) SetAskerP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) {
	if err := o.SetAsker(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetAsker of the postPrompt to the related item.
// Sets o.R.Asker to related.
// Adds o to related.R.AskerPostPrompts.
func (o *PostPrompt) SetAsker(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"post_prompts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"asker_id"}),
		strmangle.WhereClause("\"", "\"", 2, postPromptPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AskerID = related.ID
	if o.R == nil {
		o.R = &postPromptR{
			Asker: related,
		}
	} else {
		o.R.Asker = related
	}

	if related.R == nil {
		related.R = &userR{
			AskerPostPrompts: PostPromptSlice{o},
		}
	} else {
		related.R.AskerPostPrompts = append(related.R.AskerPostPrompts, o)
	}

	return nil
}

// SetPostP of the postPrompt to the related item.
// Sets o.R.Post to related.
// Adds o to related.R.PostPrompts.
// Panics on error.
func (o *PostPrompt) SetPostP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Post) {
	if err := o.SetPost(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetPost of the postPrompt to the related item.
// Sets o.R.Post to related.
// Adds o to related.R.PostPrompts.
func (o *PostPrompt) SetPost(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Post) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"post_prompts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"post_id"}),
		strmangle.WhereClause("\"", "\"", 2, postPromptPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PostID, related.ID)
	if o.R == nil {
		o.R = &postPromptR{
			Post: related,
		}
	} else {
		o.R.Post = related
	}

	if related.R == nil {
		related.R = &postR{
			PostPrompts: PostPromptSlice{o},
		}
	} else {
		related.R.PostPrompts = append(related.R.PostPrompts, o)
	}

	return nil
}

// RemovePostP relationship.
// Sets o.R.Post to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *PostPrompt) RemovePostP(ctx context.Context, exec boil.ContextExecutor, related *Post) {
	if err := o.RemovePost(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemovePost relationship.
// Sets o.R.Post to nil.
// Removes o from all passed in related items' relationships struct.
func (o *PostPrompt) RemovePost(ctx context.Context, exec boil.ContextExecutor, related *Post) error {
	var err error

	queries.SetScanner(&o.PostID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("post_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Post = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PostPrompts {
		if queries.Equal(o.PostID, ri.PostID) {
			continue
		}

		ln := len(related.R.PostPrompts)
		if ln > 1 && i < ln-1 {
			related.R.PostPrompts[i] = related.R.PostPrompts[ln-1]
		}
		related.R.PostPrompts = related.R.PostPrompts[:ln-1]
		break
	}
	return nil
}

// SetRecipientP of the postPrompt to the related item.
// Sets o.R.Recipient to related.
// Adds o to related.R.RecipientPostPrompts.
// Panics on error.
func (o *PostPrompt) SetRecipientP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) {
	if err := o.SetRecipient(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetRecipient of the postPrompt to the related item.
// Sets o.R.Recipient to related.
// Adds o to related.R.RecipientPostPrompts.
func (o *PostPrompt) SetRecipient(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"post_prompts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"recipient_id"}),
		strmangle.WhereClause("\"", "\"", 2, postPromptPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.RecipientID = related.ID
	if o.R == nil {
		o.R = &postPromptR{
			Recipient: related,
		}
	} else {
		o.R.Recipient = related
	}

	if related.R == nil {
		related.R = &userR{
			RecipientPostPrompts: PostPromptSlice{o},
		}
	} else {
		related.R.RecipientPostPrompts = append(related.R.RecipientPostPrompts, o)
	}

	return nil
}

// PostPrompts retrieves all the records using an executor.
func PostPrompts(mods ...qm.QueryMod) postPromptQuery {
	mods = append(mods, qm.From("\"post_prompts\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"post_prompts\".*"})
	}

	return postPromptQuery{q}
}

// FindPostPromptP retrieves a single record by ID with an executor, and panics on error.
func FindPostPromptP(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) *PostPrompt {
	retobj, err := FindPostPrompt(ctx, exec, iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindPostPrompt retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPostPrompt(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*PostPrompt, error) {
	postPromptObj := &PostPrompt{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"post_prompts\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, postPromptObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "core: unable to select from post_prompts")
	}

	return postPromptObj, nil
}

// InsertP a single record using an executor, and panics on error. See Insert
// for whitelist behavior description.
func (o *PostPrompt) InsertP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) {
	if err := o.Insert(ctx, exec, columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PostPrompt) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("core: no post_prompts provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(postPromptColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	postPromptInsertCacheMut.RLock()
	cache, cached := postPromptInsertCache[key]
	postPromptInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			postPromptAllColumns,
			postPromptColumnsWithDefault,
			postPromptColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(postPromptType, postPromptMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(postPromptType, postPromptMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"post_prompts\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"post_prompts\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "core: unable to insert into post_prompts")
	}

	if !cached {
		postPromptInsertCacheMut.Lock()
		postPromptInsertCache[key] = cache
		postPromptInsertCacheMut.Unlock()
	}

	return nil
}

// UpdateP uses an executor to update the PostPrompt, and panics on error.
// See Update for more documentation.
func (o *PostPrompt) UpdateP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, exec, columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Update uses an executor to update the PostPrompt.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PostPrompt) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	key := makeCacheKey(columns, nil)
	postPromptUpdateCacheMut.RLock()
	cache, cached := postPromptUpdateCache[key]
	postPromptUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			postPromptAllColumns,
			postPromptPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("core: unable to update post_prompts, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"post_prompts\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, postPromptPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(postPromptType, postPromptMapping, append(wl, postPromptPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "core: unable to update post_prompts row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "core: failed to get rows affected by update for post_prompts")
	}

	if !cached {
		postPromptUpdateCacheMut.Lock()
		postPromptUpdateCache[key] = cache
		postPromptUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAllP updates all rows with matching column names, and panics on error.
func (q postPromptQuery) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values.
func (q postPromptQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "core: unable to update all for post_prompts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "core: unable to retrieve rows affected for post_prompts")
	}

	return rowsAff, nil
}

// UpdateAllP updates all rows with the specified column values, and panics on error.
func (o PostPromptSlice) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PostPromptSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("core: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postPromptPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"post_prompts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, postPromptPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "core: unable to update all in postPrompt slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "core: unable to retrieve rows affected all in update all postPrompt")
	}
	return rowsAff, nil
}

// UpsertP attempts an insert using an executor, and does an update or ignore on conflict.
// UpsertP panics on error.
func (o *PostPrompt) UpsertP(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, exec, updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PostPrompt) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("core: no post_prompts provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(postPromptColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	postPromptUpsertCacheMut.RLock()
	cache, cached := postPromptUpsertCache[key]
	postPromptUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			postPromptAllColumns,
			postPromptColumnsWithDefault,
			postPromptColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			postPromptAllColumns,
			postPromptPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("core: unable to upsert post_prompts, could not build update column list")
		}

		ret := strmangle.SetComplement(postPromptAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(postPromptPrimaryKeyColumns) == 0 {
				return errors.New("core: unable to upsert post_prompts, could not build conflict column list")
			}

			conflict = make([]string, len(postPromptPrimaryKeyColumns))
			copy(conflict, postPromptPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"post_prompts\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(postPromptType, postPromptMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(postPromptType, postPromptMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "core: unable to upsert post_prompts")
	}

	if !cached {
		postPromptUpsertCacheMut.Lock()
		postPromptUpsertCache[key] = cache
		postPromptUpsertCacheMut.Unlock()
	}

	return nil
}

// DeleteP deletes a single PostPrompt record with an executor.
// DeleteP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *PostPrompt) DeleteP(ctx context.Context, exec boil.ContextExecutor) int64 {
	rowsAff, err := o.Delete(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Delete deletes a single PostPrompt record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PostPrompt) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("core: no PostPrompt provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), postPromptPrimaryKeyMapping)
	sql := "DELETE FROM \"post_prompts\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "core: unable to delete from post_prompts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "core: failed to get rows affected by delete for post_prompts")
	}

	return rowsAff, nil
}

// DeleteAllP deletes all rows, and panics on error.
func (q postPromptQuery) DeleteAllP(ctx context.Context, exec boil.ContextExecutor) int64 {
	rowsAff, err := q.DeleteAll(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all matching rows.
func (q postPromptQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("core: no postPromptQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "core: unable to delete all from post_prompts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "core: failed to get rows affected by deleteall for post_prompts")
	}

	return rowsAff, nil
}

// DeleteAllP deletes all rows in the slice, using an executor, and panics on error.
func (o PostPromptSlice) DeleteAllP(ctx context.Context, exec boil.ContextExecutor) int64 {
	rowsAff, err := o.DeleteAll(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PostPromptSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postPromptPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"post_prompts\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, postPromptPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "core: unable to delete all from postPrompt slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "core: failed to get rows affected by deleteall for post_prompts")
	}

	return rowsAff, nil
}

// ReloadP refetches the object from the database with an executor. Panics on error.
func (o *PostPrompt) ReloadP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.Reload(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PostPrompt) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPostPrompt(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *PostPromptSlice) ReloadAllP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.ReloadAll(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PostPromptSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PostPromptSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postPromptPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"post_prompts\".* FROM \"post_prompts\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, postPromptPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "core: unable to reload all in PostPromptSlice")
	}

	*o = slice

	return nil
}

// PostPromptExistsP checks if the PostPrompt row exists. Panics on error.
func PostPromptExistsP(ctx context.Context, exec boil.ContextExecutor, iD string) bool {
	e, err := PostPromptExists(ctx, exec, iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// PostPromptExists checks if the PostPrompt row exists.
func PostPromptExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"post_prompts\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "core: unable to check if post_prompts exists")
	}

	return exists, nil
}

// Exists checks if the PostPrompt row exists.
func (o *PostPrompt) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return PostPromptExists(ctx, exec, o.ID)
}
